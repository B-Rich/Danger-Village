#!/usr/bin/python
# -*- coding: utf-8 -*-


from Tkinter import *
import socket
import asyncore
import random
import time
import os
import tkMessageBox
import tkSimpleDialog
try:
    import cPickle as pickle
except:
    import pickle


class Client(asyncore.dispatcher_with_send):
    '''Client class for connecting to server as player'''
    
    def __init__(self, host, port, gameView):
	'''sets up client'''
        asyncore.dispatcher.__init__(self)
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect((host, port))
        data=pickle.dumps((-1,21))
        self.out_buffer = data
        self.gameView=gameView

    def handle_close(self):
        self.close()

    def handle_read(self):
	'''function that handles recivieng data, analyzes gamestate and calls function update GUI'''
	length=self.recv(4)
	time.sleep(.05)
	if length:
	    thelen=int(length)
	    data=self.recv(thelen)
	    if data:
		gamestate=pickle.loads(data)
		print gamestate,'\n'
		self.updateGame(gamestate)
		if gamestate[1]==-2:
		    self.close()
	   
	   
    def setupprocess(self, cardlist):
	'''
	adds the appropriate signal to the out buffer for the setup process
	'''
	self.out_buffer=pickle.dumps(('makeFaceUp',cardlist))

    def pickupprocess(self):
	'''
	adds the appropriate signal to the out buffer for the pickup process
	'''
	self.out_buffer=pickle.dumps(('pickupPile',[]))

    def process(self, cardlist):
	'''
	adds the appropriate signal to the out buffer for the play process
	'''
	self.out_buffer=pickle.dumps(('playCard',cardlist))

	
    def faceDownprocess(self):
	'''
	adds the appropriate signal to the out buffer for the faceDown play process
	'''
	self.out_buffer=pickle.dumps(('playFaceDownCard',[]))
	
	
    def updateGame(self,gamestate):
	'''
	updates GUI with new gamestate information recieved from the server
	'''
	 #(player,currentTurn,hand[player],currentStack,faceUpCards,lastPlay,setup,winners,CRS,getSizeOfFaceDowns,handsizes)
	player=gamestate[0]
	currentTurn=gamestate[1]
	hand=gamestate[2]
	currentStack=gamestate[3]
	faceUpCards=gamestate[4]
	lastPlay=gamestate[5]
	setup=gamestate[6]
	winners=gamestate[7]
	CRS=gamestate[8]
	faceDowns=gamestate[9]
	hands=gamestate[10]
	self.gameView.setPlayer(player)
	self.gameView.setCurrentTurn(currentTurn)
	self.gameView.setHand(hand,faceUpCards,setup,player,CRS)
	self.gameView.setCurrentStack(currentStack)
	self.gameView.setFaceUpCards(faceUpCards,faceDowns,player)
	self.gameView.setLastPlay(lastPlay, currentStack)
	self.gameView.setHands(hands)
	self.gameView.setWinners(winners)
	

class DangerVillageApp:
    '''
    '''
    def __init__(self, parent):
	
	self.currenthand=[]
	self.selectedcards=[]
	self.gifsdict = {}
	dirpath = './images/'
	for suite in zip(['s','c','d','h'],range(0,4)):
	    for card in range(2,15):
		gifname=suite[0]+str(card)+'.gif'
		gifpath = os.path.join(dirpath, gifname)
		gif = PhotoImage(file=gifpath)
		self.gifsdict[suite[1]*15+card] = gif
	for suite in [('j',0)]:
	    for card in range(1,3):
		gifname=suite[0]+str(card)+'.gif'
		gifpath = os.path.join(dirpath, gifname)
		gif = PhotoImage(file=gifpath)
		self.gifsdict[card*15-15] = gif
	gifpath = os.path.join(dirpath, 'b1fv.gif')
	gif = PhotoImage(file=gifpath)
	self.gifsdict[-1] = gif
	
	
	#sets window size
	self.myParent = parent 
	self.myParent.geometry("640x600")
	parent.title('Danger Village')
	
	
	#set up menu bar
	menubar = Menu(parent)
	filemenu = Menu(menubar, tearoff=0)
	filemenu.add_command(label="New Game", command=self.newServer)
	filemenu.add_command(label="Add Computer", command=self.addComputer)
	filemenu.add_command(label="Connect to Computer", command=self.connectToServer)
	filemenu.add_separator()
	filemenu.add_command(label="Exit", command=parent.quit)
	menubar.add_cascade(label="File", menu=filemenu)
	
	helpmenu = Menu(menubar, tearoff=0)
	helpmenu.add_command(label="Rules", command=self.help)
	menubar.add_cascade(label="Help", menu=helpmenu)
	parent.config(menu=menubar)
	
	# the window frame
	self.window = Frame(parent) ###
	self.window.pack(expand=YES, fill=BOTH)
	
	
	
	# sets up the hand frame
	self.hand_frame=Frame(self.window)
	self.hand_frame.pack(side=BOTTOM, expand=NO, fill=X, anchor=S)
	
	#set up display frames
	self.leftcardframe=Frame(self.window)
	self.leftcardframe.pack(side=LEFT, expand=NO, fill=X, anchor=E)
	
	self.rightcardframe=Frame(self.window)
	self.rightcardframe.pack(side=RIGHT, expand=NO, fill=X, anchor=W)
	
	self.bottomcardframe=Frame(self.window)
	self.bottomcardframe.pack(side=BOTTOM, expand=NO, fill=Y, anchor=S)
	
	self.topcardframe=Frame(self.window)
	self.topcardframe.pack(side=TOP, expand=NO, fill=Y, anchor=N)
	
	self.lefts=[]
	self.rights=[]
	self.bottoms=[]
	self.tops=[]
	
	# control frame - basically everything except the demo frame
	self.control_frame = Canvas(self.window) ###
	self.control_frame.pack(side=TOP, expand=NO,  padx=10, pady=5, ipadx=5, ipady=5)  	
	
	#sets up (temporary) gamestate displays
	self.playertext=Label(self.control_frame, text='', justify=LEFT)
	self.playertext.pack(side=BOTTOM, anchor=S)
	
	self.currentTurntext=Label(self.control_frame, text='', justify=LEFT)
	self.currentTurntext.pack(side=BOTTOM, anchor=S)
	
	self.currentStacktext=Label(self.control_frame, text='', justify=LEFT)
	self.currentStacktext.pack(side=BOTTOM, anchor=S)
	
	self.lastPlaytext=Label(self.control_frame, text='', justify=LEFT)
	self.lastPlaytext.pack(side=BOTTOM, anchor=S)
	
	self.lastPlaypic=Label(self.control_frame, text='', justify=LEFT)
	self.lastPlaypic.pack(side=BOTTOM, anchor=S)
	
	self.handstext=Label(self.control_frame, text='', justify=LEFT)
	self.handstext.pack(side=BOTTOM, anchor=S)
	
	self.winnerstext=Label(self.control_frame, text='', justify=LEFT)
	self.winnerstext.pack(side=BOTTOM, anchor=S)
	
	

	
	# set up for buttons
	self.buttons_frame = Frame(self.hand_frame) ###
	self.buttons_frame.pack(side=TOP, expand=NO, fill=Y, ipadx=5, ipady=5)    
	
	
	self.playButton = Button(self.buttons_frame)
	self.playButton.configure(text="Play Card")
	self.playButton.pack(side=RIGHT)
	self.playButton.focus_force()         
	self.playButton.bind("<Button-1>", self.playClick)  
	self.playButton.bind("<Return>", self.playClick) 
	
	self.setupButton = Button(self.buttons_frame)
	self.setupButton.configure(text="Setup")   
	self.setupButton.pack(side=RIGHT)
	self.setupButton.bind("<Button-1>", self.setupClick)   
	self.setupButton.bind("<Return>", self.setupClick)
	
	self.faceDownButton = Button(self.buttons_frame)
	self.faceDownButton.configure(text="Play FaceDown")   
	self.faceDownButton.pack(side=RIGHT)
	self.faceDownButton.bind("<Button-1>", self.playFaceDownClick)   
	self.faceDownButton.bind("<Return>", self.playFaceDownClick)
	
	self.pickupButton = Button(self.buttons_frame)
	self.pickupButton.configure(text="Pick up pile")   
	self.pickupButton.pack(side=RIGHT)
	self.pickupButton.bind("<Button-1>", self.pickupClick)   
	self.pickupButton.bind("<Return>", self.pickupClick)
	
	
	scrollbar = Scrollbar(self.hand_frame, orient=HORIZONTAL)
	self.handcanvas = Canvas(self.hand_frame)
	
	self.handcanvas.config(height=100,scrollregion=self.handcanvas.bbox(ALL), xscrollcommand=scrollbar.set)
	scrollbar.config(command=self.handcanvas.xview)
	scrollbar.pack(side=BOTTOM, fill=X)
	self.handcanvas.pack(side=LEFT, fill=BOTH, expand=1)
	
	#starts polling the server
	self.asynpoll()

    def help(self):
	tkMessageBox.showinfo('Rules','The point of the game is to play your cards before the other players\nThis game is a four player card game using a 54 card deck of cards (includes jokers). The game starts by shuffling the deck of cards and dealing 4 cards facedown to each player. Then 4 more cards are dealt face up so all players can see them. Then another 4 cards are dealt facedown to each player. The other cards are put aside.\nThen each player picks up the second set of facedown cards and the face up cards and chooses 4 to put face up in front of him and 4 to keep in his hand.\nThen play begins. The first player to play is decided and they play a card from their hand onto the stack. Play continues to the left. Players draw from the remaining deck of cards after they play so they have four cards until the remaining cards are gone. When a player empties his hand, he picks up his 4 face up cards. When his hand is emptied again, he plays one of his face down cards randomly. When he has played all of his face down cards and emptied his hand, that player has won.')
	tkMessageBox.showinfo('Rules for Play','A player can choose to pick up the current cards in play or play a card or combination of cards in their hand higher than the last card played. Cards are ordered from 2 to aces with aces being the highest card. Pairs of cards can be played and are worth more than all single cards and ordered from 2 to ace. Three of a kinds can also be played and similarly are worth more than all pairs and single cards. Four of a kinds will clear the pile; it will be set aside and ignored for the rest of the game.\nThere are several special cards in the game. 10s will clear the pile similar to four of a kinds. 3s are wild and can be considered any card for pairing with other cards. Jokers cause the next player to pick up the cards and skips their turn.')


    def connectToServer(self):
	output=tkSimpleDialog.askstring('Server Location','Ip Address')
	if output:
	    print "waluigi"
	    self.server.close()
	    self.client.close()
	    self.client=Client(output,8081,self)

    def newServer(self):
	self.server.close()
	self.server=Server('localhost',8081)
	self.client= Client('localhost', 8081,self)

    def addComputer(self):
	Computer('localhost',8081)


    def playFaceDownClick(self,event):
	'''
	tells the server to play a facedown card 
	'''
	try:
	    self.client.faceDownprocess()
	except:
	    print "The connection to the server has been lost. Please start a new game."
	    
    def pickupClick(self,event):
	'''
	tells the server to pick up cards
	'''
	try:
	    self.client.pickupprocess()
	except:
	    print "The connection to the server has been lost. Please start a new game."


    def playClick(self,event):
	'''
	takes selected list box cards and sends them to the server to be played
	'''
	selected= self.selectedcards
	try:
	    self.client.process(selected)
	except:
	    print "The connection to the server has been lost. Please start a new game."

    def setupClick(self,event):
	'''
	takes selected list box cards and sends them to the server to be made face up
	'''
	selected= self.selectedcards
	try:
	    self.client.setupprocess(selected)
	except:
	    print "The connection to the server has been lost. Please start a new game."
	
	
    def setPlayer(self,player):
	'''
	takes player data and reconfigures the gui features that incorporate it
	'''
	self.playertext['text']=player
	self.playertext.pack(side=TOP, anchor=W)
	
    def setCurrentTurn(self,currentTurn):
	'''
	takes current Turn and reconfigures the gui features that incorporate it
	'''
	self.currentTurntext['text']=currentTurn
	self.currentTurntext.pack(side=TOP, anchor=W)
	
    def imgclick(self,event):
	cardnum=int(event.widget.cget('text'))
	if cardnum in self.selectedcards:
	    defbg=Label().cget('bg')
	    self.selectedcards.remove(cardnum)
	    event.widget.config(bg=defbg)
	else:
	    self.selectedcards.append(cardnum)
	    event.widget.config(bg='blue')

    def setHand(self,hand,faceUpCards,setup,player,CRS):
	'''
	takes hand and reconfigures the gui features that incorporate it
	'''
	if not setup[player]:
	    hand.extend(faceUpCards[player])
	hand=sorted(hand,key=lambda card:card%CRS)
	if self.currenthand !=hand:
	    self.selectedcards=[]
	    self.currenthand=hand
	    self.handcanvas.delete(ALL)
	    handframe=Frame()
	    for card in hand:
		img = Label(handframe)
		img.bind('<Button-1>',self.imgclick)
		img.pack(side=LEFT)
		img.config(text=str(card),image=self.gifsdict[card], takefocus=1)
	    self.handcanvas.create_window(75*len(hand)/2,50,window=handframe)
	    self.myParent.lift()
	

	
    def setCurrentStack(self,currentStack):
	'''
	takes the CurrentStack and reconfigures the gui features that incorporate it
	'''
	displayStack=map(lambda x:x%15,currentStack)
	displayStack=map(lambda x: 'A' if x==14 else 'K' if x==13 else 'Q' if x==12 else 'J' if x==11 else str(x),displayStack)
	 
	self.currentStacktext['text']=displayStack
	self.currentStacktext.pack(side=BOTTOM, anchor=S)
	
    def setFaceUpCards(self,faceUpCards,faceDowns,player):
	'''
	takes faceupcards and the number of facedown cards and reconfigures the gui features that incorporate it
	'''
	self.setupRightCards(faceUpCards[(player+1)%4],faceDowns[(player+1)%4])
	self.setupLeftCards(faceUpCards[(player+3)%4],faceDowns[(player+3)%4])
	self.setupBottomCards(faceUpCards[player],faceDowns[player])
	self.setupTopCards(faceUpCards[(player+2)%4],faceDowns[(player+2)%4])
	
    def setupLeftCards(self, cards, facedown):
	for card in self.lefts:
	    card.pack_forget()
	if not cards:
	    cards=[-1]*facedown
	for card in cards:
	    img = Label(self.leftcardframe)
	    img.pack(side=TOP)
	    img.config(text=str(card),image=self.gifsdict[card], takefocus=1)
	    self.lefts.append(img)


    def setupRightCards(self, cards, facedown):
	for card in self.rights:
	    card.pack_forget()
	if not cards:
	    cards=[-1]*facedown
	for card in cards:
	    img = Label(self.rightcardframe)
	    img.pack(side=TOP)
	    img.config(text=str(card),image=self.gifsdict[card], takefocus=1)
	    self.rights.append(img)


    def setupTopCards(self, cards, facedown):
	for card in self.tops:
	    card.pack_forget()
	if not cards:
	    cards=[-1]*facedown
	for card in cards:
	    img = Label(self.topcardframe)
	    img.pack(side=RIGHT)
	    img.config(text=str(card),image=self.gifsdict[card], takefocus=1)
	    self.tops.append(img)

    def setupBottomCards(self, cards, facedown):
	for card in self.bottoms:
	    card.pack_forget()
	if not cards:
	    cards=[-1]*facedown
	for card in cards:
	    img = Label(self.bottomcardframe)
	    img.pack(side=LEFT)
	    img.config(text=str(card),image=self.gifsdict[card], takefocus=1)
	    self.bottoms.append(img)


    def setLastPlay(self,lastPlay,currentStack):
	'''
	takes lastPlay and reconfigures the gui features that incorporate it
	'''
	self.lastPlaytext['text']=lastPlay[1]
	self.lastPlaytext.pack(side=BOTTOM, anchor=S)
	if currentStack:
	    self.lastPlaypic['image']=self.gifsdict[currentStack[-1]]
	else:
	    self.lastPlaypic['image']=self.gifsdict[-1]
	self.lastPlaypic.pack(side=BOTTOM, anchor=S)
	
    def setHands(self,hands):
	'''
	takes hand sizes and reconfigures the gui features that incorporate it
	'''
	self.handstext['text']=hands
	self.handstext.pack(side=BOTTOM, anchor=S)
	
    def setWinners(self,setup):
	'''
	takes winners and reconfigures the gui features that incorporate it
	'''
	self.winnerstext['text']=setup
	self.winnerstext.pack(side=BOTTOM, anchor=S)
	
	
    def asynpoll(self):
	'''
	function that polls the network and then sets a timer to call itself again
	'''
	asyncore.poll()
	self.myParent.after(50,self.asynpoll)




class Game:
    '''class that keeps track of gamestate and allows players to play cards
    '''
    
    def variables(self):
	'''initializes all of the gamestate variables'''
	self.CRS=15#cards per suite used in constructing the deck and getting values of cards i.e. let x be the numberical representation of a card, x%CRS is the number on the card 11,12,13,14 representing jack queen king ace 0 representing jokers and 1 not existing
	self.CARDPILESIZE=4
	
	#player variables
	self.hand=([],[],[],[])
	self.faceUpCards=([],[],[],[])
	self.faceDownCards=([],[],[],[])
	self.setup=[False,False,False,False]
	
	#shared game state variables
	self.currentStack=[]
	self.lastPlay=(-1,0)
	self.currentTurn=-1
	self.players=[0,1,2,3]
	self.winners=[]
    
    def __init__(self):
	'''shuffles the deck and deals the cards out, initializing all gamestate values'''
	self.variables()
	deck=filter(lambda x: ((x%self.CRS != 0 and x%self.CRS != 1) or x==0 or x==self.CRS),range(0,self.CRS*4))
	random.shuffle(deck)
	for faceDownList,faceUpList,handList in zip(self.faceDownCards,self.faceUpCards,self.hand):
	    for x in range(self.CARDPILESIZE):
		faceDownList.append(deck.pop())
		faceUpList.append(deck.pop())
		handList.append(deck.pop())
	self.remainingDeck=deck
	
	
    def convertToPlayFormat(self, cardList):
	'''converts cardList to format specified in lastplay (card,num) or 0 if invalid'''
	def cardval(card): return card%self.CRS
	newCardList=map(cardval,cardList)
	length=len(newCardList)
	newCardset=set(newCardList)
	try:
	    newCardset.remove(3)
	except KeyError:
	    True
	if(len(newCardset)>=2):
	    return 0
	elif(len(newCardset)==0):
	    return (14,length)
	else:
	    return (newCardset.pop(),len(newCardList))
	
	
	
    def checkPlay(self,player,cardList):
	'''
	checks to see if a play made by a certain player is valid
	makes sure it is his turn, the play beats the most recently
	played card, cards are all of the same type, and cards are in hand.
	
	player is player number, 
	cardList is the cards from his handList
	
	returns 0 on invalid play, and (card, numberOfCards) if its valid (same format as lastPlay
	'''
	if (self.setup[0] and self.setup[1] and self.setup[2] and self.setup[3] and 
	cardList and self.currentTurn==player and set(cardList).issubset(self.hand[player])):
	    play=self.convertToPlayFormat(cardList)
	    if play==0:
		return 0
	    (card,num)=play
	    (pcard,pnum)=self.lastPlay
	    if card==10 or card==0 or num>3:
		return play
	    if num>pnum or (num==pnum and card>=pcard):
		return play
	return 0
	
    def playCard(self,player,cardList):
	'''
	plays the list of cards from the player specified
	checks to see if valid play
	then adds cards to stack, changes lastPlay, and performs any special operations(jokers or clears)
	then checks to see if the player has won, then changes the turn if necessary
	'''
	play=self.checkPlay(player,cardList)
	if play==0:
	    return
	(card,num)=play
	hand=[]
	hand.extend(self.hand[player])
	del self.hand[player][:]
	self.hand[player].extend(list(set(hand)^set(cardList)))
	if card == 10 or num>3:#clears
	    self.currentStack=[]
	    self.lastPlay=(-1,0)
	elif card == 0:#jokers
	    self.currentStack.extend(cardList)
	    self.hand[self.players[(self.players.index(self.currentTurn)+1)%len(self.players)]].extend(self.currentStack)
	    self.currentStack=[]
	    self.lastPlay=(-1,0)
	    self.currentTurn=self.players[(self.players.index(self.currentTurn)+2)%len(self.players)]
	else:#other cards
	    self.lastPlay=(card,num)
	    self.currentStack.extend(cardList)
	    self.currentTurn=self.players[(self.players.index(self.currentTurn)+1)%len(self.players)]
	while self.remainingDeck and len(self.hand[player])<4:
	    self.hand[player].append(self.remainingDeck.pop())
	if not self.hand[player] and self.faceUpCards[player]:
	    self.pickupFaceUpCards(player)
	if self.checkWinner(player):
	    self.winners.append(player)
	    if self.currentTurn==player:
		self.currentTurn=self.players[(self.players.index(self.currentTurn)+1)%len(self.players)]
	    self.players.remove(player)
	    if len(self.winners)==3:
		self.currentTurn=-2
		return self.winners
	    
	return None

	    
	
	
    def checkWinner(self,player):
	''' checks to see if a certain player has won. returns True if they have and False otherwise. '''
	return not (self.hand[player] or self.faceUpCards[player] or self.faceDownCards[player])
	
    def makeFaceUp(self,player,cardList):
	'''
	takes a input of a card list from the user, makes sure it is valid, and 
	then assigns those cards to be the face up cards and sets the setup flag to True.
	returns True if successful or False if incorrect cards
	'''
	if not self.setup[player] and len(cardList)==4:
	    playercards=[]
	    playercards.extend(self.hand[player])
	    playercards.extend(self.faceUpCards[player])
	    if not set(cardList).issubset(playercards):
		return False
	    del self.faceUpCards[player][:]
	    self.faceUpCards[player].extend(cardList)
	    del self.hand[player][:]
	    self.hand[player].extend(list(set(playercards)^set(cardList)))
	    self.setup[player]=True
	    if self.setup[0] and self.setup[1] and self.setup[2] and self.setup[3]:
		self.currentTurn=0
	    return True
	return False
	    
	
    def pickupPile(self,player):
	'''puts current stack into players hand'''
	self.hand[player].extend(self.currentStack)
	self.currentStack=[]
	self.lastPlay=(0,0)
    
    def playFaceDownCard(self,player):
	'''plays face down card'''
	if not self.hand[player] and not self.faceUpCards[player]:
	    randomCard=self.faceDownCards[player].pop()
	    self.hand[player].append(randomCard)
	    self.playCard(player,[randomCard])
	
	    
	
	
	
    def pickupFaceUpCards(self,player):
	'''picks up face up cards'''
	if not self.hand[player]:
	    self.hand[player].extend(self.faceUpCards[player])
	    del self.faceUpCards[player][:]
	    
	    
	    
	    
#Querying Functions-----------------------------------------------
    def getHand(self,player):
	'''returns hand'''
	def cardval(card): return card%self.CRS
	handval=map(cardval,self.hand[player])
	ret= zip(handval,self.hand[player])
	ret.sort()
	return ret
	
    def getFaceups(self):
	'''returns faceup cards of all players'''
	def cardval(card): return card%self.CRS
	retlist=[]
	for player in self.players:
	    handval=map(cardval,self.faceUpCards[player])
	    ret= zip(handval,self.faceUpCards[player])
	    ret.sort()
	    retlist.append(ret)
	return ret
	
    def getStack(self):
	def cardval(card): return card%self.CRS
	handval=map(cardval,self.currentStack)
	ret= zip(handval,self.currentStack)
	return ret
	
    def getLastPlay(self):
	return self.lastPlay
	
    def getSizeOfFaceDowns(self):
	'''returns number of cards in each facedown stack'''
	return (len(self.faceDownCards[0]),len(self.faceDownCards[1]),len(self.faceDownCards[2]),len(self.faceDownCards[3]))
	
    def getSizeOfHands(self):
	'''returns number of cards in each facedown stack'''
	return (len(self.hand[0]),len(self.hand[1]),len(self.hand[2]),len(self.hand[3]))
	
    def getGameState(self,player):
	'''returns gamestate information for use in sockets'''
	return (player,self.currentTurn,self.hand[player],self.currentStack,self.faceUpCards,self.lastPlay,self.setup,self.winners,self.CRS,self.getSizeOfFaceDowns(),self.getSizeOfHands())



class Handler(asyncore.dispatcher):

    def __init__(self, host, socket,num):
	'''creates dispatcher object to handle socket connection with one player'''
        asyncore.dispatcher.__init__(self, socket)
        self.host = host
        self.num=num
        self.outbox=[]
        print num
        
    def handle_read(self):
	'''reads in data, calls user function on gamestate, and sends new gamestate to all players'''
        data = self.recv(8192)
        if data:
	    userinput=pickle.loads(data)
	    print userinput,self.num
	    if userinput[0]=='makeFaceUp':
		self.host.game.makeFaceUp(self.num,userinput[1])
	    elif userinput[0]=='playCard':
		if not self.host.game.playCard(self.num,userinput[1]) is None:
		    self.host.handle_close()
	    elif userinput[0]=='pickupPile':
		self.host.game.pickupPile(self.num)
	    elif userinput[0]=='playFaceDownCard':
		self.host.game.playFaceDownCard(self.num)
            self.host.broadcast()
        
    def handle_close(self):
	if self.outbox:
	    message=self.outbox.pop()
	    self.send('%04d'%len(message))
	    self.send(message)
	self.close()
	

    def say(self):
	'''adds an instance of the gamestate to the outbox stack'''
	gamestate=self.host.game.getGameState(self.num)
	data=pickle.dumps(gamestate)
	self.outbox.append(data)

    def handle_write(self):
	'''sends messages in the outbox to the player'''
	if not self.outbox:
	    return
	message=self.outbox.pop()
	self.send('%04d'%len(message))
	self.send(message)

class Server(asyncore.dispatcher):

    def __init__(self, host, port):
	'''sets up server and game with the host being the server host and the port being the server port'''
	asyncore.dispatcher.__init__(self)
	self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
	self.set_reuse_addr()
	self.bind((host, port))
	self.listen(5)
	self.players=[]
	self.game=Game()
	
    def broadcast(self):
	'''sends gamestate to all players'''
	for player in self.players:
	    player.say()

    def handle_close(self):
	self.broadcast()
	for player in self.players:
	    player.handle_close()
	self.close()

    def handle_accept(self):
	'''handles someone trying to connect to game if there are less than 4 players it lets them in otherwise no'''
	pair = self.accept()
	if not (pair is None):
            sock, addr = pair
            print 'Incoming connection from %s' % repr(addr)
            if len(self.players)<4:
		self.players.append(Handler(self,sock,len(self.players)))
		
		
		
		


class Computer(asyncore.dispatcher_with_send):
    '''Computer class for connecting to server as player'''
    
    def __init__(self, host, port):
	'''sets up client'''
        asyncore.dispatcher.__init__(self)
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect((host, port))
        data=pickle.dumps((-1,21))
        self.out_buffer = data

    def handle_close(self):
        self.close()

    def handle_read(self):
	'''function that handles recivieng data, analyzes gamestate and calls functions to find return'''
	length=self.recv(4)
	time.sleep(.05)
	if length:
	    thelen=int(length)
	    data=self.recv(thelen)
        #(player,currentTurn,hand[player],currentStack,faceUpCards,lastPlay,setup,winners,CRS,getSizeOfFaceDowns,handsizes)
	    if data:
		gamestate=pickle.loads(data)
		print gamestate,'\n'
		if not gamestate[6][gamestate[0]]:#checks to see if game is setup
		    output=self.setupprocess(gamestate)
		    self.out_buffer=pickle.dumps(output)
		if gamestate[1]==gamestate[0]:#checks to see if it is currently your turn
		    output=self.process(gamestate)
		    self.out_buffer=pickle.dumps(output)
		if gamestate[1]==-2:
		    self.close()
	   
	   
    def setupprocess(self,gamestate):
	'''
	setups cards by simply retruning, can add more logic later
	returns (0,list of cards to be faceup)
	'''
	return ('makeFaceUp',gamestate[2])
	

    def process(self,gamestate):
	'''takes raw gamestate data and processes them until it decides output'''
	hand=gamestate[2]
	CRS=gamestate[8]
	lastPlay=gamestate[5]
	if not hand:
	    return ('playFaceDownCard',[])
	valuehand,values=self.getHand(hand,CRS)
	play=self.getPlay(values,lastPlay)
	return self.getCards(valuehand,play)

	
    def getHand(self,hand,CRS):
	'''
	takes card data from gamestate and returns processable card 
	information by mapping cards to their values
	
	returns a tuple of 
	a list of tuples with values, unique card number
	and a list of values with the number of cards of that value
	'''
	def cardval(card): return card%CRS
	handval=map(cardval,hand)
	ret= zip(handval,hand)
	ret.sort()
	cardcount=[]
	for i in set(handval):
	    cardcount.append((handval.count(i),i))
	cardcount.sort()
	return ret,cardcount
	
    def getPlay(self, values,lastPlay):
	'''
	the logic that decides what card will be played
	takes values in format of list of value, count
	
	accounts for logic of computer and thus can be imporved
	
	returns play in value,count format
	'''
	lastCard, lastCount=lastPlay
	for count, card in values:
	    if card != 3 and card != 10 and card !=0:
		if count>lastCount or (count==lastCount and card>=lastCard):
		    return card,count
	for count, card in values:
	    if card == 3:
		for othercount, othercard in values:
		    if othercard != 3 and othercard != 10 and othercard !=0:
			if othercount>lastCount or (othercount+count==lastCount and othercard>=lastCard):
			    return othercard,othercount+count
		if lastCount<=count:
		    return 14,count
	for count, card in values:
	    if card==0 or card==10:
		return card, 1

	return 0
	

    def getCards(self,valuehand,play):
	'''
	takes a play in the format value,card and tuples of value,card number
	returns a list of cardnums
	'''
	if play==0:
	    return ('pickupPile',[])
	cardList=[]
	count=play[1]
	for card in valuehand:
	    if card[0]==play[0]:
		cardList.append(card[1])
		count=count-1
	    if count==0:
		return ('playCard',cardList)
	for card in valuehand:
	    if card[0]==3:
		cardList.append(card[1])
		count=count-1
	    if count==0:
		return ('playCard',cardList)
	

#test code
if __name__ == '__main__': 
    root = Tk()
    myapp = DangerVillageApp(root)
    root.mainloop()
